class C:
  def __init__(self):
    self.x = 'X-man'
  
c = C()
c.x
getattr(c, 'x','not exist') 可以判断是否存在

class C:
  def __init__(self, size = 10):
    self.size = size
  def getSize(self)：
    return self.size
  def setSize(self,value):
    self.size = value
  def delSize(self):
    del self.size
  
  x = property(getSize, setSize, delSize)
  
  c = C()
  c.x = 1
  c.x
  c.size
  del c.x #c.size就不存在了
  
  
  属性访问：
  __getattr__(self,name)：试图获取一个不存在属性的行为
__getattribute__(self,name)：定义当该类的数学被访问的行为
__setattr__(self,name,value):定义当一个属性被设置的行为
__delattr__(self,name): 定义当一个属性被删除时的行为

class C:
  def __getattribute__(self,name):
    print("getattribute")
    return super().__getattribute__(name) #可以继承父类
  def __getattr__(self,name):
    print("getattr")
  def __setattr__(self,name,value):
    print("setattr")
    super().__setattr__(name,value)
  def __delattr__(self,name):
    print("delattr")
    super().__delattr__(name)
 
c = C()
c.x #会得到 getattribute 然后才是getattr
c.x = 1 #得到setattr
c.x #只会产生 getattribute, 就不会有getattr
del c.x #产生 delattr

例子：
定义个矩阵，有长和宽，当长宽一样就是正方形

class Rectanlge:
  def __init__(self, width = 0 , height = 0):
    self.width = width 
    self.height = height
  
  def __setattr__(self,name,value):
    if name == 'square':
      self.width = value
      self.height = value
    else:
      super().__setattr__(name,value) 或者 self.__dict__[name] = value
      # 不用super调用父类就会直接赋值就会进入死循环
        __dict__可以把 width，height以字典形式展示
  
  def getArea(self):
    return self.width * self.height

